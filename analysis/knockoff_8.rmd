---
title: "A detailed study of Fixed-$X$ and Model-$X$ knockoffs"
author: "Lei Sun"
date: 2018-03-01
output: workflowr::wflow_html
---





## Introduction

The idea in `Knockoff` is to generate knockoff variables $\tilde X$ which 1) keep the relationship of original variables $X$ 2) are unlike the original variables 3) are null.

### For Fixed-$X$ Knockoff

$$
\begin{array}{c}
\tilde X_i^T\tilde X_i = X_i^TX_i \\
\tilde X_i^T\tilde X_j = X_i^T \tilde X_j = \tilde X_i^T X_j = X_i^TX_j \\
\left|\tilde X_i^T X_i\right|: \text{as small as possible}
\end{array}
$$

The first two constraints are to control the Type I error, whereas the third is to increase power. Furthermore, there are two methods to make $\left|\tilde X_i^T X_i\right|$ as small as possible.

- Equi: $\tilde X_1^T X_1 = \tilde X_2^T X_2 = \cdots = \tilde X_p^T X_p \geq 0$ as close to zero as possible.
- SDP: $\tilde X_1^T X_1 + \tilde X_2^T X_2 + \cdots + \tilde X_p^T X_p$ as close to zero as possible with $\tilde X_i^T X_i \geq 0$.

### For Model-X Knockoff

$$
\begin{array}{c}
Var(X_i) = Var(\tilde X_i) \\
cor(\tilde X_i, \tilde X_j) = cor(X_i, \tilde X_j)
= cor(\tilde X_i, X_j) = cor(X_i, X_j) \\
\left|cor(\tilde X_i, X_i)\right|: \text{as small as possible}
\end{array}
$$

Similarly, the first two constraints are to control the Type I error, whereas the third is to increase power. Furthermore, there are three methods to make $\left|cor(\tilde X_i, X_i)\right|$ as small as possible.

- Equi: $cor(\tilde X_1, X_1) = cor(\tilde X_2, X_2) = \cdots = cor(\tilde X_p, X_p) \geq 0$ as close to zero as possible.
- SDP: $\left|cor(\tilde X_1, X_1)\right| + \left|cor(\tilde X_2, X_2)\right| + \cdots + \left|cor(\tilde X_p, X_p)\right|$ as small as possible.
- aSDP: An approximation to SDP to speed it up and also retain the power to some extend.

After centering $X_j$'s, the constraints on the Fix-$X$ design can be seen as the constraints on the **sample correlation** structure, whereas those on the Model-$X$ design as on the **population correlation** structure. It's no wonder the Model-$X$ design is believed to be more relaxed, and hence, more powerful.

```{r, echo = FALSE, message = FALSE}
library(knockoff)
library(Matrix)
library(reshape2)
library(ggplot2)
library(doMC)
library(lattice)
fdp <- function(selected) sum(beta[selected] == 0) / max(length(selected), 1)
power <- function(selected, k = k) sum(beta[selected] != 0) / max(k, 1)
ncores <- parallel::detectCores(all.tests = TRUE, logical = TRUE)
doMC::registerDoMC(cores = ncores)
```

```{r}
n <- 3000
p <- 1000
k <- 50
m <- 100
q <- 0.1
```

## Scenario 1: Independent Gaussian Columns

$$
X_{ij} \overset{iid}{\sim} N\left(0, \left(\frac{1}{\sqrt n}\right)^2\right)
$$

```{r indep, echo = FALSE, cache = TRUE, warning = FALSE, message = FALSE}
set.seed(777)
X <- matrix(rnorm(n * p, 0, sqrt(1 / n)), n, p)
Cov.X <- diag(1 / n, p)
Cor.X <- cov2cor(Cov.X)
Sigma.X <- crossprod(X)
R.X <- cov2cor(Sigma.X)
Rho.X <- cor(X)
Cor.betahat <- cov2cor(solve(Sigma.X))
Xk_f_e <- knockoff::create.fixed(X, method = "equi")
Xk_f_e <- Xk_f_e$Xk
Xk_f_s <- knockoff::create.fixed(X, method = "sdp")
Xk_f_s <- Xk_f_s$Xk
Xk_m_g_e <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "equi")
Xk_m_g_s <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "sdp")
Xk_m_g_a <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "asdp")
Xk_m_2_e <- knockoff::create.second_order(X, method = "equi")
Xk_m_2_s <- knockoff::create.second_order(X, method = "sdp")
Xk_m_2_a <- knockoff::create.second_order(X, method = "asdp")

corxxk <- matrix(0, p, 8)
colnames(corxxk) <- c("Fixed_Equi", "Fixed_SDP", "Model_Gaus_Equi", "Model_Gaus_SDP", "Model_Gaus_aSDP", "Model_2nd_Equi", "Model_2nd_SDP", "Model_2nd_aSDP")
for (i in 1 : p) {
  corxxk[i, 1] <- sum(X[, i] * Xk_f_e[, i]) / sqrt(sum(X[, i]^2) * sum(Xk_f_e[, i]^2))
  corxxk[i, 2] <- sum(X[, i] * Xk_f_s[, i]) / sqrt(sum(X[, i]^2) * sum(Xk_f_s[, i]^2))
  corxxk[i, 3] <- cor(X[, i], Xk_m_g_e[, i])
  corxxk[i, 4] <- cor(X[, i], Xk_m_g_s[, i])
  corxxk[i, 5] <- cor(X[, i], Xk_m_g_a[, i])
  corxxk[i, 6] <- cor(X[, i], Xk_m_2_e[, i])
  corxxk[i, 7] <- cor(X[, i], Xk_m_2_s[, i])
  corxxk[i, 8] <- cor(X[, i], Xk_m_2_a[, i])
}
```

```{r, echo = FALSE}
hist(Cor.X[lower.tri(Cor.X)], main = "Histogram of population pairwise correlation of columns in X", xlab = expression(paste("Population ", cor(X[i], X[j]))), breaks = seq(-0.45, 0.45, by = 0.1))
hist(R.X[lower.tri(R.X)], main = "Histogram of sample normalized pairwise inner product of columns in X", xlab = expression(paste("Normalized ", X[i]^T~X[j])))
hist(Rho.X[lower.tri(Rho.X)], main = "Histogram of sample pairwise correlation of columns in X", xlab = expression(paste("Sample ", cor(X[i], X[j]))))
hist(Cor.betahat[lower.tri(Cor.betahat)], main = expression(paste("Histogram of population pairwise correlation of ", hat(beta))), xlab = expression(paste("Population ", cor(hat(beta)[i], hat(beta)[j]))))
par(mfrow = c(1, 1))
par(mar = c(9, 2.5, 2.5, 1.5))
boxplot(corxxk, las = 2, main = "Similarity between originals and their knockoffs")
```

### Fixed Design

```{r indep fixed, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
A <- 4
beta <- rep(0, p)
nonzero <- sample(p, k)
beta[nonzero] <- A

W <- result <- list()
for (i in 1 : m) {
  y <- X %*% beta + rnorm(n)

  ## Least squares
  lm.fit <- lm(y ~ X - 1)
  pvalue <- summary(lm.fit)$coefficients[, 4]

  ## BH
  BH.fit <- p.adjust(pvalue, method = "BH")
  BH.selected <- (1 : p)[BH.fit <= q]

  orig <- 1 : p
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::lasso_max_lambda(cbind(X, Xk_f_e)[, random.order.variable], y, method = "glmnet", family = "gaussian")
  Z <- Z[order(random.order.variable)]
  W_f_e_max <- pmax(Z[orig], Z[orig + p]) * sign(Z[orig] - Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::lasso_max_lambda(cbind(X, Xk_f_s)[, random.order.variable], y, method = "glmnet", family = "gaussian")
  Z <- Z[order(random.order.variable)]
  W_f_s_max <- pmax(Z[orig], Z[orig + p]) * sign(Z[orig] - Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_f_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  Xk_f_e_diff <- abs(Z[orig]) - abs(Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_f_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  Xk_f_s_diff <- abs(Z[orig]) - abs(Z[orig + p])

  ## Knockoff
  W[[i]] <- cbind(
    equi_max <- knockoff::stat.glmnet_lambdasmax(X, Xk_f_e, y),
    equi_max_random <- W_f_e_max,
    sdp_max <- knockoff::stat.glmnet_lambdasmax(X, Xk_f_s, y),
    sdp_max_random <- W_f_s_max,
    equi_diff <- knockoff::stat.glmnet_coefdiff(X, Xk_f_e, y, cores = ncores),
    equi_diff_random <- Xk_f_e_diff,
    sdp_diff <- knockoff::stat.glmnet_coefdiff(X, Xk_f_s, y, cores = ncores),
    sdp_diff_random <- Xk_f_s_diff
  )

  Knockoff.threshold <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 0)
  Knockoff.threshold.plus <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 1)

  fdp.Knockoff <- fdp.Knockoff.plus <- power.Knockoff <- power.Knockoff.plus <- c()
  for (j in 1 : ncol(W[[i]])) {
    fdp.Knockoff[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold[j]))
    fdp.Knockoff.plus[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold.plus[j]))
    power.Knockoff[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold[j])] != 0) / max(k, 1)
    power.Knockoff.plus[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold.plus[j])] != 0) / max(k, 1)
  }

  result[[i]] <- c(
    fdp(BH.selected), fdp.Knockoff, fdp.Knockoff.plus,
    power(BH.selected, k), power.Knockoff, power.Knockoff.plus
  )
}
```

```{r, echo = FALSE, message = FALSE}
par(mar = c(9, 4.5, 0.5, 0.5))
result.matrix <- matrix(unlist(result), m, byrow = TRUE)
boxplot(result.matrix[, 1 : 17], ylab = "FDP", las = 2, names = c(
  "BH",
  "KO.Equi.lambdasmax",
  "KO.Equi.lambdasmax.Rand",
  "KO.SDP.lambdasmax",
  "KO.SDP.lambdasmax.Rand",
  "KO.Equi.coefdiff",
  "KO.Equi.coefdiff.Rand",
  "KO.SDP.coefdiff",
  "KO.SDP.coefdiff.Rand",
  "KO+.Equi.lambdasmax",
  "KO+.Equi.lambdasmax.Rand",
  "KO+.SDP.lambdasmax",
  "KO+.SDP.lambdasmax.Rand",
  "KO+.Equi.coefdiff",
  "KO+.Equi.coefdiff.Rand",
  "KO+.SDP.coefdiff",
  "KO+.SDP.coefdiff.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 1 : 17]), col = "blue", pch = 3)
abline(h = q, lty = 2, col = "red")
abline(v = c(1.5, 9.5), col = "maroon")

boxplot(result.matrix[, 18 : 34], ylab = "TDP", las = 2, names = c(
  "BH",
  "KO.Equi.lambdasmax",
  "KO.Equi.lambdasmax.Rand",
  "KO.SDP.lambdasmax",
  "KO.SDP.lambdasmax.Rand",
  "KO.Equi.coefdiff",
  "KO.Equi.coefdiff.Rand",
  "KO.SDP.coefdiff",
  "KO.SDP.coefdiff.Rand",
  "KO+.Equi.lambdasmax",
  "KO+.Equi.lambdasmax.Rand",
  "KO+.SDP.lambdasmax",
  "KO+.SDP.lambdasmax.Rand",
  "KO+.Equi.coefdiff",
  "KO+.Equi.coefdiff.Rand",
  "KO+.SDP.coefdiff",
  "KO+.SDP.coefdiff.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 18 : 34]), col = "blue", pch = 3)
abline(v = c(1.5, 9.5), col = "maroon")

null <- setdiff(seq(p), nonzero)
W.sign <- lapply(W, apply, 2, function(x)(sum(x[null] > 0) / sum(x[null] != 0)))
W.sign <- matrix(unlist(W.sign), m, byrow = TRUE)
colnames(W.sign) <- c(
  "Equi + lambdasmax",
  "Equi + lambdasmax + Random",
  "SDP + lambdasmax",
  "SDP + lambdasmax + Random",
  "Equi + coefdiff",
  "Equi + coefdiff + Random",
  "SDP + coefdiff",
  "SDP + coefdiff + Random"
)

ggplot2::ggplot(data = reshape2::melt(as.data.frame(W.sign)), mapping = aes(x = value)) +
  geom_histogram(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~ variable, ncol = 2) +
  labs(x = "Proportion of Null Test Statistics Being Positive") +
  geom_vline(xintercept = 0.5, col = "red", linetype = "dashed")
```

### Model-$X$ Design

```{r indep model, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
A <- 4

nonzero.list <- W <- W.sign <- result <- list()

for (i in 1 : m) {
  X <- matrix(rnorm(n * p, 0, sqrt(1 / n)), n, p)

  Xk_m_g_e <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "equi")
  Xk_m_g_s <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "sdp")
  Xk_m_2_e <- knockoff::create.second_order(X, method = "equi")
  Xk_m_2_s <- knockoff::create.second_order(X, method = "sdp")
  
  beta <- rep(0, p)
  nonzero <- sample(p, k)
  nonzero.list[[i]] <- nonzero
  null <- setdiff(seq(p), nonzero)
  beta[nonzero] <- A
  
  y <- X %*% beta + rnorm(n)
  
  ## Least squares
  lm.fit <- lm(y ~ X - 1)
  pvalue <- summary(lm.fit)$coefficients[, 4]

  ## BH
  BH.fit <- p.adjust(pvalue, method = "BH")
  BH.selected <- (1 : p)[BH.fit <= q]

  orig <- 1 : p
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_g_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_g_e <- abs(Z[orig]) - abs(Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_g_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_g_s <- abs(Z[orig]) - abs(Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_2_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_2_e <- abs(Z[orig]) - abs(Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_2_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_2_s <- abs(Z[orig]) - abs(Z[orig + p])

  ## Knockoff
  W[[i]] <- cbind(
    gauss_equi <- knockoff::stat.glmnet_coefdiff(X, Xk_m_g_e, y, cores = ncores),
    gauss_equi_random <- W_m_g_e,
    gauss_sdp <- knockoff::stat.glmnet_coefdiff(X, Xk_m_g_s, y, cores = ncores),
    gauss_sdp_random <- W_m_g_s,
    est_equi <- knockoff::stat.glmnet_coefdiff(X, Xk_m_2_e, y, cores = ncores),
    est_equi_random <- W_m_2_e,
    est_sdp <- knockoff::stat.glmnet_coefdiff(X, Xk_m_2_s, y, cores = ncores),
    est_sdp_random <- W_m_2_s
  )
  
  W.sign[[i]] <- apply(W[[i]], 2, function (x) {sum(x[null] > 0) / sum(x[null] != 0)})

  Knockoff.threshold <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 0)
  Knockoff.threshold.plus <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 1)

  fdp.Knockoff <- fdp.Knockoff.plus <- power.Knockoff <- power.Knockoff.plus <- c()
  for (j in 1 : ncol(W[[i]])) {
    fdp.Knockoff[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold[j]))
    fdp.Knockoff.plus[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold.plus[j]))
    power.Knockoff[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold[j])] != 0) / max(k, 1)
    power.Knockoff.plus[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold.plus[j])] != 0) / max(k, 1)
  }

  result[[i]] <- c(
    fdp(BH.selected), fdp.Knockoff, fdp.Knockoff.plus,
    power(BH.selected, k), power.Knockoff, power.Knockoff.plus
  )
}
```

```{r, echo = FALSE, message = FALSE}
par(mar = c(9, 4.5, 0.5, 0.5))
result.matrix <- matrix(unlist(result), m, byrow = TRUE)
boxplot(result.matrix[, 1 : 17], ylab = "FDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 1 : 17]), col = "blue", pch = 3)
abline(h = q, lty = 2, col = "red")
abline(v = c(1.5, 9.5), col = "maroon")

boxplot(result.matrix[, 18 : 34], ylab = "TDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 18 : 34]), col = "blue", pch = 3)
abline(v = c(1.5, 9.5), col = "maroon")

W.sign.matrix <- matrix(unlist(W.sign), m, byrow = TRUE)
colnames(W.sign.matrix) <- c(
  "Gauss + Equi",
  "Gauss + Equi + Random",
  "Gauss + SDP",
  "Gauss + SDP + Random",
  "2nd + Equi",
  "2nd + Equi + Random",
  "2nd + SDP",
  "2nd + SDP + Random"
)

ggplot2::ggplot(data = reshape2::melt(as.data.frame(W.sign.matrix)), mapping = aes(x = value)) +
  geom_histogram(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~ variable, ncol = 2) +
  labs(x = "Proportion of Null Test Statistics Being Positive") +
  geom_vline(xintercept = 0.5, col = "red", linetype = "dashed")
```

## Scenario 2: Equal-correlation

$$
\begin{array}{c}
X_{ij} \sim N\left(0, \left(\frac{1}{\sqrt n}\right)^2\right) \\
cor(X_{ij}, X_{ij'}) \equiv \rho
\end{array}
$$

### $\rho = 0.5$

```{r equal-cor, echo = FALSE, cache = TRUE, warning = FALSE, message = FALSE}
set.seed(777)
rho <- 0.5
Z <- rnorm(n, 0, sqrt(1 / n))
X <- sqrt(rho) * Z + sqrt(1 - rho) * matrix(rnorm(n * p, 0, sqrt(1 / n)), n, p)
Cov.X <- (1 - rho) * diag(1 / n, p) + rho * matrix(1 / n, p, p)
Cor.X <- cov2cor(Cov.X)
Sigma.X <- crossprod(X)
R.X <- cov2cor(Sigma.X)
Rho.X <- cor(X)
Cor.betahat <- cov2cor(solve(Sigma.X))
Xk_f_e <- knockoff::create.fixed(X, method = "equi")
Xk_f_e <- Xk_f_e$Xk
Xk_f_s <- knockoff::create.fixed(X, method = "sdp")
Xk_f_s <- Xk_f_s$Xk
Xk_m_g_e <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "equi")
Xk_m_g_s <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "sdp")
Xk_m_g_a <- data.frame(matrix(0, n, p))
tryCatch({Xk_m_g_a <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "asdp")}, error = function(w){Xk_m_g_a <- data.frame(matrix(0, n, p))})
Xk_m_2_e <- knockoff::create.second_order(X, method = "equi")
Xk_m_2_s <- knockoff::create.second_order(X, method = "sdp")
Xk_m_2_a <- data.frame(matrix(0, n, p))
tryCatch({Xk_m_2_a <- knockoff::create.second_order(X, method = "asdp")}, error = function(w){Xk_m_2_a <- data.frame(matrix(0, n, p))})

corxxk <- matrix(0, p, 8)
colnames(corxxk) <- c("Fixed_Equi", "Fixed_SDP", "Model_Gaus_Equi", "Model_Gaus_SDP", "Model_Gaus_aSDP", "Model_2nd_Equi", "Model_2nd_SDP", "Model_2nd_aSDP")
for (i in 1 : p) {
  corxxk[i, 1] <- sum(X[, i] * Xk_f_e[, i]) / sqrt(sum(X[, i]^2) * sum(Xk_f_e[, i]^2))
  corxxk[i, 2] <- sum(X[, i] * Xk_f_s[, i]) / sqrt(sum(X[, i]^2) * sum(Xk_f_s[, i]^2))
  corxxk[i, 3] <- cor(X[, i], Xk_m_g_e[, i])
  corxxk[i, 4] <- cor(X[, i], Xk_m_g_s[, i])
  corxxk[i, 5] <- cor(X[, i], Xk_m_g_a[, i])
  corxxk[i, 6] <- cor(X[, i], Xk_m_2_e[, i])
  corxxk[i, 7] <- cor(X[, i], Xk_m_2_s[, i])
  corxxk[i, 8] <- cor(X[, i], Xk_m_2_a[, i])
}
```

```{r, echo = FALSE}
hist(Cor.X[lower.tri(Cor.X)], main = "Histogram of population pairwise correlation of columns in X", xlab = expression(paste("Population ", cor(X[i], X[j]))), breaks = seq(0.05, 0.95, by = 0.1))
hist(R.X[lower.tri(R.X)], main = "Histogram of sample normalized pairwise inner product of columns in X", xlab = expression(paste("Normalized ", X[i]^T~X[j])))
hist(Rho.X[lower.tri(Rho.X)], main = "Histogram of sample pairwise correlation of columns in X", xlab = expression(paste("Sample ", cor(X[i], X[j]))))
hist(Cor.betahat[lower.tri(Cor.betahat)], main = expression(paste("Histogram of population pairwise correlation of ", hat(beta))), xlab = expression(paste("Population ", cor(hat(beta)[i], hat(beta)[j]))))
par(mfrow = c(1, 1))
par(mar = c(9, 2.5, 2.5, 1.5))
boxplot(corxxk, las = 2, main = "Similarity between originals and their knockoffs")
```

#### Fixed Design

```{r equal-cor fixed, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
A <- 5
beta <- rep(0, p)
nonzero <- sample(p, k)
beta[nonzero] <- A

W <- result <- list()
for (i in 1 : m) {
  y <- X %*% beta + rnorm(n)

  ## Least squares
  lm.fit <- lm(y ~ X - 1)
  pvalue <- summary(lm.fit)$coefficients[, 4]

  ## BH
  BH.fit <- p.adjust(pvalue, method = "BH")
  BH.selected <- (1 : p)[BH.fit <= q]

  orig <- 1 : p
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::lasso_max_lambda(cbind(X, Xk_f_e)[, random.order.variable], y, method = "glmnet", family = "gaussian")
  Z <- Z[order(random.order.variable)]
  W_f_e_max <- pmax(Z[orig], Z[orig + p]) * sign(Z[orig] - Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::lasso_max_lambda(cbind(X, Xk_f_s)[, random.order.variable], y, method = "glmnet", family = "gaussian")
  Z <- Z[order(random.order.variable)]
  W_f_s_max <- pmax(Z[orig], Z[orig + p]) * sign(Z[orig] - Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_f_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  Xk_f_e_diff <- abs(Z[orig]) - abs(Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_f_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  Xk_f_s_diff <- abs(Z[orig]) - abs(Z[orig + p])

  ## Knockoff
  W[[i]] <- cbind(
    equi_max <- knockoff::stat.glmnet_lambdasmax(X, Xk_f_e, y),
    equi_max_random <- W_f_e_max,
    sdp_max <- knockoff::stat.glmnet_lambdasmax(X, Xk_f_s, y),
    sdp_max_random <- W_f_s_max,
    equi_diff <- knockoff::stat.glmnet_coefdiff(X, Xk_f_e, y, cores = ncores),
    equi_diff_random <- Xk_f_e_diff,
    sdp_diff <- knockoff::stat.glmnet_coefdiff(X, Xk_f_s, y, cores = ncores),
    sdp_diff_random <- Xk_f_s_diff
  )
  
  Knockoff.threshold <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 0)
  Knockoff.threshold.plus <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 1)

  fdp.Knockoff <- fdp.Knockoff.plus <- power.Knockoff <- power.Knockoff.plus <- c()
  for (j in 1 : ncol(W[[i]])) {
    fdp.Knockoff[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold[j]))
    fdp.Knockoff.plus[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold.plus[j]))
    power.Knockoff[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold[j])] != 0) / max(k, 1)
    power.Knockoff.plus[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold.plus[j])] != 0) / max(k, 1)
  }

  result[[i]] <- c(
    fdp(BH.selected), fdp.Knockoff, fdp.Knockoff.plus,
    power(BH.selected, k), power.Knockoff, power.Knockoff.plus
  )
}
```

```{r, echo = FALSE, message = FALSE}
par(mar = c(9, 4.5, 0.5, 0.5))
result.matrix <- matrix(unlist(result), m, byrow = TRUE)
boxplot(result.matrix[, 1 : 17], ylab = "FDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 1 : 17]), col = "blue", pch = 3)
abline(h = q, lty = 2, col = "red")
abline(v = c(1.5, 9.5), col = "maroon")

boxplot(result.matrix[, 18 : 34], ylab = "TDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 18 : 34]), col = "blue", pch = 3)
abline(v = c(1.5, 9.5), col = "maroon")

W.sign.matrix <- matrix(unlist(W.sign), m, byrow = TRUE)
colnames(W.sign.matrix) <- c(
  "Gauss + Equi",
  "Gauss + Equi + Random",
  "Gauss + SDP",
  "Gauss + SDP + Random",
  "2nd + Equi",
  "2nd + Equi + Random",
  "2nd + SDP",
  "2nd + SDP + Random"
)

ggplot2::ggplot(data = reshape2::melt(as.data.frame(W.sign.matrix)), mapping = aes(x = value)) +
  geom_histogram(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~ variable, ncol = 2) +
  labs(x = "Proportion of Null Test Statistics Being Positive") +
  geom_vline(xintercept = 0.5, col = "red", linetype = "dashed")
```

#### Model-$X$ Design

```{r equal-cor model, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
A <- 5

nonzero.list <- W <- W.sign <- result <- list()

for (i in 1 : m) {
  Z <- rnorm(n, 0, sqrt(1 / n))
  X <- sqrt(rho) * Z + sqrt(1 - rho) * matrix(rnorm(n * p, 0, sqrt(1 / n)), n, p)

  Xk_m_g_e <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "equi")
  Xk_m_g_s <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "sdp")
  Xk_m_2_e <- knockoff::create.second_order(X, method = "equi")
  Xk_m_2_s <- knockoff::create.second_order(X, method = "sdp")
  
  beta <- rep(0, p)
  nonzero <- sample(p, k)
  nonzero.list[[i]] <- nonzero
  null <- setdiff(seq(p), nonzero)
  beta[nonzero] <- A
  
  y <- X %*% beta + rnorm(n)
  
  ## Least squares
  lm.fit <- lm(y ~ X - 1)
  pvalue <- summary(lm.fit)$coefficients[, 4]

  ## BH
  BH.fit <- p.adjust(pvalue, method = "BH")
  BH.selected <- (1 : p)[BH.fit <= q]

  orig <- 1 : p
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_g_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_g_e <- abs(Z[orig]) - abs(Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_g_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_g_s <- abs(Z[orig]) - abs(Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_2_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_2_e <- abs(Z[orig]) - abs(Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_2_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_2_s <- abs(Z[orig]) - abs(Z[orig + p])

  ## Knockoff
  W[[i]] <- cbind(
    gauss_equi <- knockoff::stat.glmnet_coefdiff(X, Xk_m_g_e, y, cores = ncores),
    gauss_equi_random <- W_m_g_e,
    gauss_sdp <- knockoff::stat.glmnet_coefdiff(X, Xk_m_g_s, y, cores = ncores),
    gauss_sdp_random <- W_m_g_s,
    est_equi <- knockoff::stat.glmnet_coefdiff(X, Xk_m_2_e, y, cores = ncores),
    est_equi_random <- W_m_2_e,
    est_sdp <- knockoff::stat.glmnet_coefdiff(X, Xk_m_2_s, y, cores = ncores),
    est_sdp_random <- W_m_2_s
  )
  
  W.sign[[i]] <- apply(W[[i]], 2, function (x) {sum(x[null] > 0) / sum(x[null] != 0)})

  Knockoff.threshold <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 0)
  Knockoff.threshold.plus <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 1)

  fdp.Knockoff <- fdp.Knockoff.plus <- power.Knockoff <- power.Knockoff.plus <- c()
  for (j in 1 : ncol(W[[i]])) {
    fdp.Knockoff[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold[j]))
    fdp.Knockoff.plus[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold.plus[j]))
    power.Knockoff[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold[j])] != 0) / max(k, 1)
    power.Knockoff.plus[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold.plus[j])] != 0) / max(k, 1)
  }

  result[[i]] <- c(
    fdp(BH.selected), fdp.Knockoff, fdp.Knockoff.plus,
    power(BH.selected, k), power.Knockoff, power.Knockoff.plus
  )
}
```

```{r, echo = FALSE, message = FALSE}
par(mar = c(9, 4.5, 0.5, 0.5))
result.matrix <- matrix(unlist(result), m, byrow = TRUE)
boxplot(result.matrix[, 1 : 17], ylab = "FDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 1 : 17]), col = "blue", pch = 3)
abline(h = q, lty = 2, col = "red")
abline(v = c(1.5, 9.5), col = "maroon")

boxplot(result.matrix[, 18 : 34], ylab = "TDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 18 : 34]), col = "blue", pch = 3)
abline(v = c(1.5, 9.5), col = "maroon")


W.sign.matrix <- matrix(unlist(W.sign), m, byrow = TRUE)
colnames(W.sign.matrix) <- c(
  "Gauss + Equi",
  "Gauss + Equi + Random",
  "Gauss + SDP",
  "Gauss + SDP + Random",
  "2nd + Equi",
  "2nd + Equi + Random",
  "2nd + SDP",
  "2nd + SDP + Random"
)

ggplot2::ggplot(data = reshape2::melt(as.data.frame(W.sign.matrix)), mapping = aes(x = value)) +
  geom_histogram(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~ variable, ncol = 2) +
  labs(x = "Proportion of Null Test Statistics Being Positive") +
  geom_vline(xintercept = 0.5, col = "red", linetype = "dashed")
```

### $\rho = 0.99$

```{r equal-cor-2, echo = FALSE, cache = TRUE, warning = FALSE, message = FALSE}
set.seed(777)
rho <- 0.99
Z <- rnorm(n, 0, sqrt(1 / n))
X <- sqrt(rho) * Z + sqrt(1 - rho) * matrix(rnorm(n * p, 0, sqrt(1 / n)), n, p)
Cov.X <- (1 - rho) * diag(1 / n, p) + rho * matrix(1 / n, p, p)
Cor.X <- cov2cor(Cov.X)
Sigma.X <- crossprod(X)
R.X <- cov2cor(Sigma.X)
Rho.X <- cor(X)
Cor.betahat <- cov2cor(solve(Sigma.X))
Xk_f_e <- knockoff::create.fixed(X, method = "equi")
Xk_f_e <- Xk_f_e$Xk
Xk_f_s <- knockoff::create.fixed(X, method = "sdp")
Xk_f_s <- Xk_f_s$Xk
Xk_m_g_e <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "equi")
Xk_m_g_s <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "sdp")
Xk_m_g_a <- data.frame(matrix(0, n, p))
tryCatch({Xk_m_g_a <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "asdp")}, error = function(w){Xk_m_g_a <- data.frame(matrix(0, n, p))})
Xk_m_2_e <- knockoff::create.second_order(X, method = "equi")
Xk_m_2_s <- knockoff::create.second_order(X, method = "sdp")
Xk_m_2_a <- data.frame(matrix(0, n, p))
tryCatch({Xk_m_2_a <- knockoff::create.second_order(X, method = "asdp")}, error = function(w){Xk_m_2_a <- data.frame(matrix(0, n, p))})

corxxk <- matrix(0, p, 8)
colnames(corxxk) <- c("Fixed_Equi", "Fixed_SDP", "Model_Gaus_Equi", "Model_Gaus_SDP", "Model_Gaus_aSDP", "Model_2nd_Equi", "Model_2nd_SDP", "Model_2nd_aSDP")
for (i in 1 : p) {
  corxxk[i, 1] <- sum(X[, i] * Xk_f_e[, i]) / sqrt(sum(X[, i]^2) * sum(Xk_f_e[, i]^2))
  corxxk[i, 2] <- sum(X[, i] * Xk_f_s[, i]) / sqrt(sum(X[, i]^2) * sum(Xk_f_s[, i]^2))
  corxxk[i, 3] <- cor(X[, i], Xk_m_g_e[, i])
  corxxk[i, 4] <- cor(X[, i], Xk_m_g_s[, i])
  corxxk[i, 5] <- cor(X[, i], Xk_m_g_a[, i])
  corxxk[i, 6] <- cor(X[, i], Xk_m_2_e[, i])
  corxxk[i, 7] <- cor(X[, i], Xk_m_2_s[, i])
  corxxk[i, 8] <- cor(X[, i], Xk_m_2_a[, i])
}
```

```{r, echo = FALSE}
hist(Cor.X[lower.tri(Cor.X)], main = "Histogram of population pairwise correlation of columns in X", xlab = expression(paste("Population ", cor(X[i], X[j]))), breaks = seq(0.9805, 0.9995, by = 0.001))
hist(R.X[lower.tri(R.X)], main = "Histogram of sample normalized pairwise inner product of columns in X", xlab = expression(paste("Normalized ", X[i]^T~X[j])))
hist(Rho.X[lower.tri(Rho.X)], main = "Histogram of sample pairwise correlation of columns in X", xlab = expression(paste("Sample ", cor(X[i], X[j]))))
hist(Cor.betahat[lower.tri(Cor.betahat)], main = expression(paste("Histogram of population pairwise correlation of ", hat(beta))), xlab = expression(paste("Population ", cor(hat(beta)[i], hat(beta)[j]))))
par(mfrow = c(1, 1))
par(mar = c(9, 2.5, 2.5, 1.5))
boxplot(corxxk, las = 2, main = "Similarity between originals and their knockoffs")
```

#### Fixed Design

```{r equal-cor-2 fixed, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
A <- 40
beta <- rep(0, p)
nonzero <- sample(p, k)
beta[nonzero] <- A

W <- result <- list()
for (i in 1 : m) {
  y <- X %*% beta + rnorm(n)

  ## Least squares
  lm.fit <- lm(y ~ X - 1)
  pvalue <- summary(lm.fit)$coefficients[, 4]

  ## BH
  BH.fit <- p.adjust(pvalue, method = "BH")
  BH.selected <- (1 : p)[BH.fit <= q]

  orig <- 1 : p
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::lasso_max_lambda(cbind(X, Xk_f_e)[, random.order.variable], y, method = "glmnet", family = "gaussian")
  Z <- Z[order(random.order.variable)]
  W_f_e_max <- pmax(Z[orig], Z[orig + p]) * sign(Z[orig] - Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::lasso_max_lambda(cbind(X, Xk_f_s)[, random.order.variable], y, method = "glmnet", family = "gaussian")
  Z <- Z[order(random.order.variable)]
  W_f_s_max <- pmax(Z[orig], Z[orig + p]) * sign(Z[orig] - Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_f_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  Xk_f_e_diff <- abs(Z[orig]) - abs(Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_f_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  Xk_f_s_diff <- abs(Z[orig]) - abs(Z[orig + p])

  ## Knockoff
  W[[i]] <- cbind(
    equi_max <- knockoff::stat.glmnet_lambdasmax(X, Xk_f_e, y),
    equi_max_random <- W_f_e_max,
    sdp_max <- knockoff::stat.glmnet_lambdasmax(X, Xk_f_s, y),
    sdp_max_random <- W_f_s_max,
    equi_diff <- knockoff::stat.glmnet_coefdiff(X, Xk_f_e, y, cores = ncores),
    equi_diff_random <- Xk_f_e_diff,
    sdp_diff <- knockoff::stat.glmnet_coefdiff(X, Xk_f_s, y, cores = ncores),
    sdp_diff_random <- Xk_f_s_diff
  )

  Knockoff.threshold <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 0)
  Knockoff.threshold.plus <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 1)

  fdp.Knockoff <- fdp.Knockoff.plus <- power.Knockoff <- power.Knockoff.plus <- c()
  for (j in 1 : ncol(W[[i]])) {
    fdp.Knockoff[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold[j]))
    fdp.Knockoff.plus[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold.plus[j]))
    power.Knockoff[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold[j])] != 0) / max(k, 1)
    power.Knockoff.plus[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold.plus[j])] != 0) / max(k, 1)
  }

  result[[i]] <- c(
    fdp(BH.selected), fdp.Knockoff, fdp.Knockoff.plus,
    power(BH.selected, k), power.Knockoff, power.Knockoff.plus
  )
}
```

```{r, echo = FALSE, message = FALSE}
par(mar = c(9, 4.5, 0.5, 0.5))
result.matrix <- matrix(unlist(result), m, byrow = TRUE)
boxplot(result.matrix[, 1 : 17], ylab = "FDP", las = 2, names = c(
  "BH",
  "KO.Equi.lambdasmax",
  "KO.Equi.lambdasmax.Rand",
  "KO.SDP.lambdasmax",
  "KO.SDP.lambdasmax.Rand",
  "KO.Equi.coefdiff",
  "KO.Equi.coefdiff.Rand",
  "KO.SDP.coefdiff",
  "KO.SDP.coefdiff.Rand",
  "KO+.Equi.lambdasmax",
  "KO+.Equi.lambdasmax.Rand",
  "KO+.SDP.lambdasmax",
  "KO+.SDP.lambdasmax.Rand",
  "KO+.Equi.coefdiff",
  "KO+.Equi.coefdiff.Rand",
  "KO+.SDP.coefdiff",
  "KO+.SDP.coefdiff.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 1 : 17]), col = "blue", pch = 3)
abline(h = q, lty = 2, col = "red")
abline(v = c(1.5, 9.5), col = "maroon")

boxplot(result.matrix[, 18 : 34], ylab = "TDP", las = 2, names = c(
  "BH",
  "KO.Equi.lambdasmax",
  "KO.Equi.lambdasmax.Rand",
  "KO.SDP.lambdasmax",
  "KO.SDP.lambdasmax.Rand",
  "KO.Equi.coefdiff",
  "KO.Equi.coefdiff.Rand",
  "KO.SDP.coefdiff",
  "KO.SDP.coefdiff.Rand",
  "KO+.Equi.lambdasmax",
  "KO+.Equi.lambdasmax.Rand",
  "KO+.SDP.lambdasmax",
  "KO+.SDP.lambdasmax.Rand",
  "KO+.Equi.coefdiff",
  "KO+.Equi.coefdiff.Rand",
  "KO+.SDP.coefdiff",
  "KO+.SDP.coefdiff.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 18 : 34]), col = "blue", pch = 3)
abline(v = c(1.5, 9.5), col = "maroon")

null <- setdiff(seq(p), nonzero)
W.sign <- lapply(W, apply, 2, function(x)(sum(x[null] > 0) / sum(x[null] != 0)))
W.sign <- matrix(unlist(W.sign), m, byrow = TRUE)
colnames(W.sign) <- c(
  "Equi + lambdasmax",
  "Equi + lambdasmax + Random",
  "SDP + lambdasmax",
  "SDP + lambdasmax + Random",
  "Equi + coefdiff",
  "Equi + coefdiff + Random",
  "SDP + coefdiff",
  "SDP + coefdiff + Random"
)

ggplot2::ggplot(data = reshape2::melt(as.data.frame(W.sign)), mapping = aes(x = value)) +
  geom_histogram(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~ variable, ncol = 2) +
  labs(x = "Proportion of Null Test Statistics Being Positive") +
  geom_vline(xintercept = 0.5, col = "red", linetype = "dashed")
```

#### Model-$X$ Design

```{r equal-cor-2 model, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
A <- 40

nonzero.list <- W.sign <- W <- result <- list()

for (i in 1 : m) {
  Z <- rnorm(n, 0, sqrt(1 / n))
  X <- sqrt(rho) * Z + sqrt(1 - rho) * matrix(rnorm(n * p, 0, sqrt(1 / n)), n, p)

  Xk_m_g_e <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "equi")
  Xk_m_g_s <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "sdp")
  Xk_m_2_e <- knockoff::create.second_order(X, method = "equi")
  Xk_m_2_s <- knockoff::create.second_order(X, method = "sdp")
  
  beta <- rep(0, p)
  nonzero <- sample(p, k)
  nonzero.list[[i]] <- nonzero
  null <- setdiff(seq(p), nonzero)
  beta[nonzero] <- A
  
  y <- X %*% beta + rnorm(n)
  
  ## Least squares
  lm.fit <- lm(y ~ X - 1)
  pvalue <- summary(lm.fit)$coefficients[, 4]

  ## BH
  BH.fit <- p.adjust(pvalue, method = "BH")
  BH.selected <- (1 : p)[BH.fit <= q]

  orig <- 1 : p
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_g_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_g_e <- abs(Z[orig]) - abs(Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_g_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_g_s <- abs(Z[orig]) - abs(Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_2_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_2_e <- abs(Z[orig]) - abs(Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_2_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_2_s <- abs(Z[orig]) - abs(Z[orig + p])

  ## Knockoff
  W[[i]] <- cbind(
    gauss_equi <- knockoff::stat.glmnet_coefdiff(X, Xk_m_g_e, y, cores = ncores),
    gauss_equi_random <- W_m_g_e,
    gauss_sdp <- knockoff::stat.glmnet_coefdiff(X, Xk_m_g_s, y, cores = ncores),
    gauss_sdp_random <- W_m_g_s,
    est_equi <- knockoff::stat.glmnet_coefdiff(X, Xk_m_2_e, y, cores = ncores),
    est_equi_random <- W_m_2_e,
    est_sdp <- knockoff::stat.glmnet_coefdiff(X, Xk_m_2_s, y, cores = ncores),
    est_sdp_random <- W_m_2_s
  )
  
  W.sign[[i]] <- apply(W[[i]], 2, function (x) {sum(x[null] > 0) / sum(x[null] != 0)})

  Knockoff.threshold <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 0)
  Knockoff.threshold.plus <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 1)

  fdp.Knockoff <- fdp.Knockoff.plus <- power.Knockoff <- power.Knockoff.plus <- c()
  for (j in 1 : ncol(W[[i]])) {
    fdp.Knockoff[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold[j]))
    fdp.Knockoff.plus[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold.plus[j]))
    power.Knockoff[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold[j])] != 0) / max(k, 1)
    power.Knockoff.plus[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold.plus[j])] != 0) / max(k, 1)
  }

  result[[i]] <- c(
    fdp(BH.selected), fdp.Knockoff, fdp.Knockoff.plus,
    power(BH.selected, k), power.Knockoff, power.Knockoff.plus
  )
}
```

```{r, echo = FALSE, message = FALSE}
par(mar = c(9, 4.5, 0.5, 0.5))
result.matrix <- matrix(unlist(result), m, byrow = TRUE)
boxplot(result.matrix[, 1 : 17], ylab = "FDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 1 : 17]), col = "blue", pch = 3)
abline(h = q, lty = 2, col = "red")
abline(v = c(1.5, 9.5), col = "maroon")

boxplot(result.matrix[, 18 : 34], ylab = "TDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 18 : 34]), col = "blue", pch = 3)
abline(v = c(1.5, 9.5), col = "maroon")

W.sign.matrix <- matrix(unlist(W.sign), m, byrow = TRUE)
colnames(W.sign.matrix) <- c(
  "Gauss + Equi",
  "Gauss + Equi + Random",
  "Gauss + SDP",
  "Gauss + SDP + Random",
  "2nd + Equi",
  "2nd + Equi + Random",
  "2nd + SDP",
  "2nd + SDP + Random"
)

ggplot2::ggplot(data = reshape2::melt(as.data.frame(W.sign.matrix)), mapping = aes(x = value)) +
  geom_histogram(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~ variable, ncol = 2) +
  labs(x = "Proportion of Null Test Statistics Being Positive") +
  geom_vline(xintercept = 0.5, col = "red", linetype = "dashed")
```

## Scenario 3: Extreme local correlation

$$
\begin{array}{c}
X_{ij} \sim N\left(0, \left(\frac{1}{\sqrt n}\right)^2\right) \\
cor(X_{i1}, X_{i2})  = cor(X_{i3}, X_{i4}) = \cdots = cor(X_{i(p-1)}, X_{ip}) = \rho = 0.99
\end{array}
$$

```{r extr-local-cor, echo = FALSE, cache = TRUE, warning = FALSE, message = FALSE}
set.seed(777)
rho <- 0.99
Z1 <- matrix(rnorm(n * p / 2, 0, sqrt(1 / n)), n)
Z2 <- rho * Z1 + sqrt(1 - rho^2) * matrix(rnorm(n * p / 2, 0, sqrt(1 / n)), n)
X <- matrix(0, n, p)
X[, seq(1, p, by = 2)] = Z1
X[, seq(2, p, by = 2)] = Z2
cor.x <- matrix(c(1, rho, rho, 1), 2, 2)
cor.x.list <- list()
for (i in 1 : (p / 2)) {cor.x.list[[i]] <- cor.x}
Cor.X <- as.matrix(Matrix::bdiag(cor.x.list))
Cov.X <- Cor.X * 1 / n
Sigma.X <- crossprod(X)
R.X <- cov2cor(Sigma.X)
Rho.X <- cor(X)
Cor.betahat <- cov2cor(solve(Sigma.X))
Xk_f_e <- knockoff::create.fixed(X, method = "equi")
Xk_f_e <- Xk_f_e$Xk
Xk_f_s <- knockoff::create.fixed(X, method = "sdp")
Xk_f_s <- Xk_f_s$Xk
Xk_m_g_e <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "equi")
Xk_m_g_s <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "sdp")
Xk_m_g_a <- data.frame(matrix(0, n, p))
tryCatch({Xk_m_g_a <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "asdp")}, error = function(e){Xk_m_g_a <- data.frame(matrix(0, n, p))})
Xk_m_2_e <- knockoff::create.second_order(X, method = "equi")
Xk_m_2_s <- knockoff::create.second_order(X, method = "sdp")
Xk_m_2_a <- data.frame(matrix(0, n, p))
tryCatch({Xk_m_2_a <- knockoff::create.second_order(X, method = "asdp")}, error = function(e){Xk_m_2_a <- data.frame(matrix(0, n, p))})

corxxk <- matrix(0, p, 8)
colnames(corxxk) <- c("Fixed_Equi", "Fixed_SDP", "Model_Gaus_Equi", "Model_Gaus_SDP", "Model_Gaus_aSDP", "Model_2nd_Equi", "Model_2nd_SDP", "Model_2nd_aSDP")
for (i in 1 : p) {
  corxxk[i, 1] <- sum(X[, i] * Xk_f_e[, i]) / sqrt(sum(X[, i]^2) * sum(Xk_f_e[, i]^2))
  corxxk[i, 2] <- sum(X[, i] * Xk_f_s[, i]) / sqrt(sum(X[, i]^2) * sum(Xk_f_s[, i]^2))
  corxxk[i, 3] <- cor(X[, i], Xk_m_g_e[, i])
  corxxk[i, 4] <- cor(X[, i], Xk_m_g_s[, i])
  corxxk[i, 5] <- cor(X[, i], Xk_m_g_a[, i])
  corxxk[i, 6] <- cor(X[, i], Xk_m_2_e[, i])
  corxxk[i, 7] <- cor(X[, i], Xk_m_2_s[, i])
  corxxk[i, 8] <- cor(X[, i], Xk_m_2_a[, i])
}
```

```{r, echo = FALSE}
hist(Cor.X[lower.tri(Cor.X)], main = "Histogram of population pairwise correlation of columns in X", xlab = expression(paste("Population ", cor(X[i], X[j]))))
hist(R.X[lower.tri(R.X)], main = "Histogram of sample normalized pairwise inner product of columns in X", xlab = expression(paste("Normalized ", X[i]^T~X[j])))
hist(Rho.X[lower.tri(Rho.X)], main = "Histogram of sample pairwise correlation of columns in X", xlab = expression(paste("Sample ", cor(X[i], X[j]))))
hist(Cor.betahat[lower.tri(Cor.betahat)], main = expression(paste("Histogram of population pairwise correlation of ", hat(beta))), xlab = expression(paste("Population ", cor(hat(beta)[i], hat(beta)[j]))))
par(mfrow = c(1, 1))
par(mar = c(9, 3.5, 2.5, 1.5))
boxplot(corxxk, las = 2, main = "Similarity between originals and their knockoffs")
```

### Fixed Design

```{r extr-local-cor fixed, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
A <- 30
beta <- rep(0, p)
nonzero <- sample(seq(1, p, by = 2), k)
beta[nonzero] <- A

W <- result <- list()
for (i in 1 : m) {
  y <- X %*% beta + rnorm(n)

  ## Least squares
  lm.fit <- lm(y ~ X - 1)
  pvalue <- summary(lm.fit)$coefficients[, 4]

  ## BH
  BH.fit <- p.adjust(pvalue, method = "BH")
  BH.selected <- (1 : p)[BH.fit <= q]

  orig <- 1 : p
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::lasso_max_lambda(cbind(X, Xk_f_e)[, random.order.variable], y, method = "glmnet", family = "gaussian")
  Z <- Z[order(random.order.variable)]
  W_f_e_max <- pmax(Z[orig], Z[orig + p]) * sign(Z[orig] - Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::lasso_max_lambda(cbind(X, Xk_f_s)[, random.order.variable], y, method = "glmnet", family = "gaussian")
  Z <- Z[order(random.order.variable)]
  W_f_s_max <- pmax(Z[orig], Z[orig + p]) * sign(Z[orig] - Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_f_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  Xk_f_e_diff <- abs(Z[orig]) - abs(Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_f_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  Xk_f_s_diff <- abs(Z[orig]) - abs(Z[orig + p])

  ## Knockoff
  W[[i]] <- cbind(
    equi_max <- knockoff::stat.glmnet_lambdasmax(X, Xk_f_e, y),
    equi_max_random <- W_f_e_max,
    sdp_max <- knockoff::stat.glmnet_lambdasmax(X, Xk_f_s, y),
    sdp_max_random <- W_f_s_max,
    equi_diff <- knockoff::stat.glmnet_coefdiff(X, Xk_f_e, y, cores = ncores),
    equi_diff_random <- Xk_f_e_diff,
    sdp_diff <- knockoff::stat.glmnet_coefdiff(X, Xk_f_s, y, cores = ncores),
    sdp_diff_random <- Xk_f_s_diff
  )

  Knockoff.threshold <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 0)
  Knockoff.threshold.plus <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 1)

  fdp.Knockoff <- fdp.Knockoff.plus <- power.Knockoff <- power.Knockoff.plus <- c()
  for (j in 1 : ncol(W[[i]])) {
    fdp.Knockoff[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold[j]))
    fdp.Knockoff.plus[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold.plus[j]))
    power.Knockoff[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold[j])] != 0) / max(k, 1)
    power.Knockoff.plus[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold.plus[j])] != 0) / max(k, 1)
  }

  result[[i]] <- c(
    fdp(BH.selected), fdp.Knockoff, fdp.Knockoff.plus,
    power(BH.selected, k), power.Knockoff, power.Knockoff.plus
  )
}
```

```{r, echo = FALSE, message = FALSE}
par(mar = c(9, 4.5, 0.5, 0.5))
result.matrix <- matrix(unlist(result), m, byrow = TRUE)
boxplot(result.matrix[, 1 : 17], ylab = "FDP", las = 2, names = c(
  "BH",
  "KO.Equi.lambdasmax",
  "KO.Equi.lambdasmax.Rand",
  "KO.SDP.lambdasmax",
  "KO.SDP.lambdasmax.Rand",
  "KO.Equi.coefdiff",
  "KO.Equi.coefdiff.Rand",
  "KO.SDP.coefdiff",
  "KO.SDP.coefdiff.Rand",
  "KO+.Equi.lambdasmax",
  "KO+.Equi.lambdasmax.Rand",
  "KO+.SDP.lambdasmax",
  "KO+.SDP.lambdasmax.Rand",
  "KO+.Equi.coefdiff",
  "KO+.Equi.coefdiff.Rand",
  "KO+.SDP.coefdiff",
  "KO+.SDP.coefdiff.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 1 : 17]), col = "blue", pch = 3)
abline(h = q, lty = 2, col = "red")
abline(v = c(1.5, 9.5), col = "maroon")

boxplot(result.matrix[, 18 : 34], ylab = "TDP", las = 2, names = c(
  "BH",
  "KO.Equi.lambdasmax",
  "KO.Equi.lambdasmax.Rand",
  "KO.SDP.lambdasmax",
  "KO.SDP.lambdasmax.Rand",
  "KO.Equi.coefdiff",
  "KO.Equi.coefdiff.Rand",
  "KO.SDP.coefdiff",
  "KO.SDP.coefdiff.Rand",
  "KO+.Equi.lambdasmax",
  "KO+.Equi.lambdasmax.Rand",
  "KO+.SDP.lambdasmax",
  "KO+.SDP.lambdasmax.Rand",
  "KO+.Equi.coefdiff",
  "KO+.Equi.coefdiff.Rand",
  "KO+.SDP.coefdiff",
  "KO+.SDP.coefdiff.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 18 : 34]), col = "blue", pch = 3)
abline(v = c(1.5, 9.5), col = "maroon")

null <- setdiff(seq(p), nonzero)
W.sign <- lapply(W, apply, 2, function(x)(sum(x[null] > 0) / sum(x[null] != 0)))
W.sign <- matrix(unlist(W.sign), m, byrow = TRUE)
colnames(W.sign) <- c(
  "Equi + lambdasmax",
  "Equi + lambdasmax + Random",
  "SDP + lambdasmax",
  "SDP + lambdasmax + Random",
  "Equi + coefdiff",
  "Equi + coefdiff + Random",
  "SDP + coefdiff",
  "SDP + coefdiff + Random"
)

ggplot2::ggplot(data = reshape2::melt(as.data.frame(W.sign)), mapping = aes(x = value)) +
  geom_histogram(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~ variable, ncol = 2) +
  labs(x = "Proportion of Null Test Statistics Being Positive") +
  geom_vline(xintercept = 0.5, col = "red", linetype = "dashed")
```

### Model-$X$ Design

```{r extr-local-cor model, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
A <- 30

nonzero.list <- W.sign <- W <- result <- list()

for (i in 1 : m) {
  Z1 <- matrix(rnorm(n * p / 2, 0, sqrt(1 / n)), n)
  Z2 <- rho * Z1 + sqrt(1 - rho^2) * matrix(rnorm(n * p / 2, 0, sqrt(1 / n)), n)
  X <- matrix(0, n, p)
  X[, seq(1, p, by = 2)] = Z1
  X[, seq(2, p, by = 2)] = Z2

  Xk_m_g_e <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "equi")
  Xk_m_g_s <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "sdp")
  Xk_m_2_e <- knockoff::create.second_order(X, method = "equi")
  Xk_m_2_s <- knockoff::create.second_order(X, method = "sdp")
  
  beta <- rep(0, p)
  nonzero <- sample(seq(1, p, by = 2), k)
  nonzero.list[[i]] <- nonzero
  null <- setdiff(seq(p), nonzero)
  beta[nonzero] <- A

  y <- X %*% beta + rnorm(n)
  
  ## Least squares
  lm.fit <- lm(y ~ X - 1)
  pvalue <- summary(lm.fit)$coefficients[, 4]

  ## BH
  BH.fit <- p.adjust(pvalue, method = "BH")
  BH.selected <- (1 : p)[BH.fit <= q]

  orig <- 1 : p
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_g_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_g_e <- abs(Z[orig]) - abs(Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_g_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_g_s <- abs(Z[orig]) - abs(Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_2_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_2_e <- abs(Z[orig]) - abs(Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_2_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_2_s <- abs(Z[orig]) - abs(Z[orig + p])

  ## Knockoff
  W[[i]] <- cbind(
    gauss_equi <- knockoff::stat.glmnet_coefdiff(X, Xk_m_g_e, y, cores = ncores),
    gauss_equi_random <- W_m_g_e,
    gauss_sdp <- knockoff::stat.glmnet_coefdiff(X, Xk_m_g_s, y, cores = ncores),
    gauss_sdp_random <- W_m_g_s,
    est_equi <- knockoff::stat.glmnet_coefdiff(X, Xk_m_2_e, y, cores = ncores),
    est_equi_random <- W_m_2_e,
    est_sdp <- knockoff::stat.glmnet_coefdiff(X, Xk_m_2_s, y, cores = ncores),
    est_sdp_random <- W_m_2_s
  )

  W.sign[[i]] <- apply(W[[i]], 2, function (x) {sum(x[null] > 0) / sum(x[null] != 0)})
  
  Knockoff.threshold <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 0)
  Knockoff.threshold.plus <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 1)

  fdp.Knockoff <- fdp.Knockoff.plus <- power.Knockoff <- power.Knockoff.plus <- c()
  for (j in 1 : ncol(W[[i]])) {
    fdp.Knockoff[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold[j]))
    fdp.Knockoff.plus[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold.plus[j]))
    power.Knockoff[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold[j])] != 0) / max(k, 1)
    power.Knockoff.plus[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold.plus[j])] != 0) / max(k, 1)
  }

  result[[i]] <- c(
    fdp(BH.selected), fdp.Knockoff, fdp.Knockoff.plus,
    power(BH.selected, k), power.Knockoff, power.Knockoff.plus
  )
}
```

```{r, echo = FALSE, message = FALSE}
par(mar = c(9, 4.5, 0.5, 0.5))
result.matrix <- matrix(unlist(result), m, byrow = TRUE)
boxplot(result.matrix[, 1 : 17], ylab = "FDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 1 : 17]), col = "blue", pch = 3)
abline(h = q, lty = 2, col = "red")
abline(v = c(1.5, 9.5), col = "maroon")

boxplot(result.matrix[, 18 : 34], ylab = "TDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 18 : 34]), col = "blue", pch = 3)
abline(v = c(1.5, 9.5), col = "maroon")

W.sign.matrix <- matrix(unlist(W.sign), m, byrow = TRUE)
colnames(W.sign.matrix) <- c(
  "Gauss + Equi",
  "Gauss + Equi + Random",
  "Gauss + SDP",
  "Gauss + SDP + Random",
  "2nd + Equi",
  "2nd + Equi + Random",
  "2nd + SDP",
  "2nd + SDP + Random"
)

ggplot2::ggplot(data = reshape2::melt(as.data.frame(W.sign.matrix)), mapping = aes(x = value)) +
  geom_histogram(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~ variable, ncol = 2) +
  labs(x = "Proportion of Null Test Statistics Being Positive") +
  geom_vline(xintercept = 0.5, col = "red", linetype = "dashed")
```

## Scenario 4: Factor Model for $X$

$$
\begin{array}{c}
\text{each row }X_{i}^T \sim N\left(0, \frac{1}n\Sigma_{p}\right) \\
\Sigma_p = \texttt{cov2cor}(B_{p \times d}B_{d\times p}^T + I)\\
B_{ij} \overset{iid}{\sim} N(0, 1)
\end{array}
$$

```{r factor-x, echo = FALSE, cache = TRUE, warning = FALSE, message = FALSE}
set.seed(777)
d <- 5
B <- matrix(rnorm(p * d), p, d)
Cor.X <- cov2cor(tcrossprod(B) + diag(p))
Cov.X <- Cor.X / n
X <- matrix(rnorm(n * p, 0, sqrt(1 / n)), n) %*% chol(Cor.X)
Sigma.X <- crossprod(X)
R.X <- cov2cor(Sigma.X)
Rho.X <- cor(X)
Cor.betahat <- cov2cor(solve(Sigma.X))
Xk_f_e <- knockoff::create.fixed(X, method = "equi")
Xk_f_e <- Xk_f_e$Xk
Xk_f_s <- knockoff::create.fixed(X, method = "sdp")
Xk_f_s <- Xk_f_s$Xk
Xk_m_g_e <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "equi")
Xk_m_g_s <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "sdp")
Xk_m_g_a <- data.frame(matrix(0, n, p))
tryCatch({Xk_m_g_a <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "asdp")}, error = function(e){Xk_m_g_a <- data.frame(matrix(0, n, p))})
Xk_m_2_e <- knockoff::create.second_order(X, method = "equi")
Xk_m_2_s <- knockoff::create.second_order(X, method = "sdp")
Xk_m_2_a <- data.frame(matrix(0, n, p))
tryCatch({Xk_m_2_a <- knockoff::create.second_order(X, method = "asdp")}, error = function(e){Xk_m_g_a <- data.frame(matrix(0, n, p))})

corxxk <- matrix(0, p, 8)
colnames(corxxk) <- c("Fixed_Equi", "Fixed_SDP", "Model_Gaus_Equi", "Model_Gaus_SDP", "Model_Gaus_aSDP", "Model_2nd_Equi", "Model_2nd_SDP", "Model_2nd_aSDP")
for (i in 1 : p) {
  corxxk[i, 1] <- sum(X[, i] * Xk_f_e[, i]) / sqrt(sum(X[, i]^2) * sum(Xk_f_e[, i]^2))
  corxxk[i, 2] <- sum(X[, i] * Xk_f_s[, i]) / sqrt(sum(X[, i]^2) * sum(Xk_f_s[, i]^2))
  corxxk[i, 3] <- cor(X[, i], Xk_m_g_e[, i])
  corxxk[i, 4] <- cor(X[, i], Xk_m_g_s[, i])
  corxxk[i, 5] <- cor(X[, i], Xk_m_g_a[, i])
  corxxk[i, 6] <- cor(X[, i], Xk_m_2_e[, i])
  corxxk[i, 7] <- cor(X[, i], Xk_m_2_s[, i])
  corxxk[i, 8] <- cor(X[, i], Xk_m_2_a[, i])
}
```

```{r, echo = FALSE}
hist(Cor.X[lower.tri(Cor.X)], main = "Histogram of population pairwise correlation of columns in X", xlab = expression(paste("Population ", cor(X[i], X[j]))))
hist(R.X[lower.tri(R.X)], main = "Histogram of sample normalized pairwise inner product of columns in X", xlab = expression(paste("Normalized ", X[i]^T~X[j])))
hist(Rho.X[lower.tri(Rho.X)], main = "Histogram of sample pairwise correlation of columns in X", xlab = expression(paste("Sample ", cor(X[i], X[j]))))
hist(Cor.betahat[lower.tri(Cor.betahat)], main = expression(paste("Histogram of population pairwise correlation of ", hat(beta))), xlab = expression(paste("Population ", cor(hat(beta)[i], hat(beta)[j]))))
par(mfrow = c(1, 1))
par(mar = c(9, 3.5, 2.5, 1.5))
boxplot(corxxk, las = 2, main = "Similarity between originals and their knockoffs")
```

### Fixed Design

```{r factor-x fixed, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
A <- 10
beta <- rep(0, p)
nonzero <- sample(p, k)
beta[nonzero] <- A

W <- result <- list()
for (i in 1 : m) {
  y <- X %*% beta + rnorm(n)

  ## Least squares
  lm.fit <- lm(y ~ X - 1)
  pvalue <- summary(lm.fit)$coefficients[, 4]

  ## BH
  BH.fit <- p.adjust(pvalue, method = "BH")
  BH.selected <- (1 : p)[BH.fit <= q]

  orig <- 1 : p
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::lasso_max_lambda(cbind(X, Xk_f_e)[, random.order.variable], y, method = "glmnet", family = "gaussian")
  Z <- Z[order(random.order.variable)]
  W_f_e_max <- pmax(Z[orig], Z[orig + p]) * sign(Z[orig] - Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::lasso_max_lambda(cbind(X, Xk_f_s)[, random.order.variable], y, method = "glmnet", family = "gaussian")
  Z <- Z[order(random.order.variable)]
  W_f_s_max <- pmax(Z[orig], Z[orig + p]) * sign(Z[orig] - Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_f_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  Xk_f_e_diff <- abs(Z[orig]) - abs(Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_f_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  Xk_f_s_diff <- abs(Z[orig]) - abs(Z[orig + p])

  ## Knockoff
  W[[i]] <- cbind(
    equi_max <- knockoff::stat.glmnet_lambdasmax(X, Xk_f_e, y),
    equi_max_random <- W_f_e_max,
    sdp_max <- knockoff::stat.glmnet_lambdasmax(X, Xk_f_s, y),
    sdp_max_random <- W_f_s_max,
    equi_diff <- knockoff::stat.glmnet_coefdiff(X, Xk_f_e, y, cores = ncores),
    equi_diff_random <- Xk_f_e_diff,
    sdp_diff <- knockoff::stat.glmnet_coefdiff(X, Xk_f_s, y, cores = ncores),
    sdp_diff_random <- Xk_f_s_diff
  )

  Knockoff.threshold <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 0)
  Knockoff.threshold.plus <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 1)

  fdp.Knockoff <- fdp.Knockoff.plus <- power.Knockoff <- power.Knockoff.plus <- c()
  for (j in 1 : ncol(W[[i]])) {
    fdp.Knockoff[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold[j]))
    fdp.Knockoff.plus[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold.plus[j]))
    power.Knockoff[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold[j])] != 0) / max(k, 1)
    power.Knockoff.plus[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold.plus[j])] != 0) / max(k, 1)
  }

  result[[i]] <- c(
    fdp(BH.selected), fdp.Knockoff, fdp.Knockoff.plus,
    power(BH.selected, k), power.Knockoff, power.Knockoff.plus
  )
}
```

```{r, echo = FALSE, message = FALSE}
par(mar = c(9, 4.5, 0.5, 0.5))
result.matrix <- matrix(unlist(result), m, byrow = TRUE)
boxplot(result.matrix[, 1 : 17], ylab = "FDP", las = 2, names = c(
  "BH",
  "KO.Equi.lambdasmax",
  "KO.Equi.lambdasmax.Rand",
  "KO.SDP.lambdasmax",
  "KO.SDP.lambdasmax.Rand",
  "KO.Equi.coefdiff",
  "KO.Equi.coefdiff.Rand",
  "KO.SDP.coefdiff",
  "KO.SDP.coefdiff.Rand",
  "KO+.Equi.lambdasmax",
  "KO+.Equi.lambdasmax.Rand",
  "KO+.SDP.lambdasmax",
  "KO+.SDP.lambdasmax.Rand",
  "KO+.Equi.coefdiff",
  "KO+.Equi.coefdiff.Rand",
  "KO+.SDP.coefdiff",
  "KO+.SDP.coefdiff.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 1 : 17]), col = "blue", pch = 3)
abline(h = q, lty = 2, col = "red")
abline(v = c(1.5, 9.5), col = "maroon")

boxplot(result.matrix[, 18 : 34], ylab = "TDP", las = 2, names = c(
  "BH",
  "KO.Equi.lambdasmax",
  "KO.Equi.lambdasmax.Rand",
  "KO.SDP.lambdasmax",
  "KO.SDP.lambdasmax.Rand",
  "KO.Equi.coefdiff",
  "KO.Equi.coefdiff.Rand",
  "KO.SDP.coefdiff",
  "KO.SDP.coefdiff.Rand",
  "KO+.Equi.lambdasmax",
  "KO+.Equi.lambdasmax.Rand",
  "KO+.SDP.lambdasmax",
  "KO+.SDP.lambdasmax.Rand",
  "KO+.Equi.coefdiff",
  "KO+.Equi.coefdiff.Rand",
  "KO+.SDP.coefdiff",
  "KO+.SDP.coefdiff.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 18 : 34]), col = "blue", pch = 3)
abline(v = c(1.5, 9.5), col = "maroon")

null <- setdiff(seq(p), nonzero)
W.sign <- lapply(W, apply, 2, function(x)(sum(x[null] > 0) / sum(x[null] != 0)))
W.sign <- matrix(unlist(W.sign), m, byrow = TRUE)
colnames(W.sign) <- c(
  "Equi + lambdasmax",
  "Equi + lambdasmax + Random",
  "SDP + lambdasmax",
  "SDP + lambdasmax + Random",
  "Equi + coefdiff",
  "Equi + coefdiff + Random",
  "SDP + coefdiff",
  "SDP + coefdiff + Random"
)

ggplot2::ggplot(data = reshape2::melt(as.data.frame(W.sign)), mapping = aes(x = value)) +
  geom_histogram(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~ variable, ncol = 2) +
  labs(x = "Proportion of Null Test Statistics Being Positive") +
  geom_vline(xintercept = 0.5, col = "red", linetype = "dashed")
```

### Model-$X$ Design

```{r factor-x model, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
A <- 10

nonzero.list <- W.sign <- W <- result <- list()

for (i in 1 : m) {
  X <- matrix(rnorm(n * p, 0, sqrt(1 / n)), n) %*% chol(Cor.X)

  Xk_m_g_e <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "equi")
  Xk_m_g_s <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "sdp")
  Xk_m_2_e <- knockoff::create.second_order(X, method = "equi")
  Xk_m_2_s <- knockoff::create.second_order(X, method = "sdp")
  
  beta <- rep(0, p)
  nonzero <- sample(p, k)
  nonzero.list[[i]] <- nonzero
  null <- setdiff(seq(p), nonzero)
  beta[nonzero] <- A
  
  y <- X %*% beta + rnorm(n)
  
  ## Least squares
  lm.fit <- lm(y ~ X - 1)
  pvalue <- summary(lm.fit)$coefficients[, 4]

  ## BH
  BH.fit <- p.adjust(pvalue, method = "BH")
  BH.selected <- (1 : p)[BH.fit <= q]

  orig <- 1 : p
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_g_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_g_e <- abs(Z[orig]) - abs(Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_g_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_g_s <- abs(Z[orig]) - abs(Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_2_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_2_e <- abs(Z[orig]) - abs(Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_2_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_2_s <- abs(Z[orig]) - abs(Z[orig + p])

  ## Knockoff
  W[[i]] <- cbind(
    gauss_equi <- knockoff::stat.glmnet_coefdiff(X, Xk_m_g_e, y, cores = ncores),
    gauss_equi_random <- W_m_g_e,
    gauss_sdp <- knockoff::stat.glmnet_coefdiff(X, Xk_m_g_s, y, cores = ncores),
    gauss_sdp_random <- W_m_g_s,
    est_equi <- knockoff::stat.glmnet_coefdiff(X, Xk_m_2_e, y, cores = ncores),
    est_equi_random <- W_m_2_e,
    est_sdp <- knockoff::stat.glmnet_coefdiff(X, Xk_m_2_s, y, cores = ncores),
    est_sdp_random <- W_m_2_s
  )
  
  W.sign[[i]] <- apply(W[[i]], 2, function (x) {sum(x[null] > 0) / sum(x[null] != 0)})

  Knockoff.threshold <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 0)
  Knockoff.threshold.plus <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 1)

  fdp.Knockoff <- fdp.Knockoff.plus <- power.Knockoff <- power.Knockoff.plus <- c()
  for (j in 1 : ncol(W[[i]])) {
    fdp.Knockoff[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold[j]))
    fdp.Knockoff.plus[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold.plus[j]))
    power.Knockoff[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold[j])] != 0) / max(k, 1)
    power.Knockoff.plus[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold.plus[j])] != 0) / max(k, 1)
  }

  result[[i]] <- c(
    fdp(BH.selected), fdp.Knockoff, fdp.Knockoff.plus,
    power(BH.selected, k), power.Knockoff, power.Knockoff.plus
  )
}
```

```{r, echo = FALSE, message = FALSE}
par(mar = c(9, 4.5, 0.5, 0.5))
result.matrix <- matrix(unlist(result), m, byrow = TRUE)
boxplot(result.matrix[, 1 : 17], ylab = "FDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 1 : 17]), col = "blue", pch = 3)
abline(h = q, lty = 2, col = "red")
abline(v = c(1.5, 9.5), col = "maroon")

boxplot(result.matrix[, 18 : 34], ylab = "TDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 18 : 34]), col = "blue", pch = 3)
abline(v = c(1.5, 9.5), col = "maroon")

W.sign.matrix <- matrix(unlist(W.sign), m, byrow = TRUE)
colnames(W.sign.matrix) <- c(
  "Gauss + Equi",
  "Gauss + Equi + Random",
  "Gauss + SDP",
  "Gauss + SDP + Random",
  "2nd + Equi",
  "2nd + Equi + Random",
  "2nd + SDP",
  "2nd + SDP + Random"
)

ggplot2::ggplot(data = reshape2::melt(as.data.frame(W.sign.matrix)), mapping = aes(x = value)) +
  geom_histogram(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~ variable, ncol = 2) +
  labs(x = "Proportion of Null Test Statistics Being Positive") +
  geom_vline(xintercept = 0.5, col = "red", linetype = "dashed")
```

## Scenario 5: Factor Model for $\hat\beta$

$$
\begin{array}{c}
\text{each row }X_{i}^T \sim N\left(0, \frac{1}n\Sigma_{p}\right) \\
\Sigma_p = \texttt{cov2cor}(\left(B_{p \times d}B_{d\times p}^T + I\right)^{-1})\\
B_{ij} \overset{iid}{\sim} N(0, 1)
\end{array}
$$

```{r factor-betahat, echo = FALSE, cache = TRUE, warning = FALSE, message = FALSE}
set.seed(777)
d <- 5
B <- matrix(rnorm(p * d), p, d)
Cor.X <- cov2cor(round(solve(tcrossprod(B) + diag(p)), 4))
Cov.X <- Cor.X / n
X <- matrix(rnorm(n * p, 0, sqrt(1 / n)), n) %*% chol(Cor.X)
Sigma.X <- crossprod(X)
R.X <- cov2cor(Sigma.X)
Rho.X <- cor(X)
Cor.betahat <- cov2cor(solve(Sigma.X))
Xk_f_e <- knockoff::create.fixed(X, method = "equi")
Xk_f_e <- Xk_f_e$Xk
Xk_f_s <- knockoff::create.fixed(X, method = "sdp")
Xk_f_s <- Xk_f_s$Xk
Xk_m_g_e <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "equi")
Xk_m_g_s <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "sdp")
Xk_m_g_a <- data.frame(matrix(0, n, p))
tryCatch({Xk_m_g_a <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "asdp")}, error = function(e){Xk_m_g_a <- data.frame(matrix(0, n, p))})
Xk_m_2_e <- knockoff::create.second_order(X, method = "equi")
Xk_m_2_s <- knockoff::create.second_order(X, method = "sdp")
Xk_m_2_a <- data.frame(matrix(0, n, p))
tryCatch({Xk_m_2_a <- knockoff::create.second_order(X, method = "asdp")}, error = function(e){Xk_m_2_a <- data.frame(matrix(0, n, p))})

corxxk <- matrix(0, p, 8)
colnames(corxxk) <- c("Fixed_Equi", "Fixed_SDP", "Model_Gaus_Equi", "Model_Gaus_SDP", "Model_Gaus_aSDP", "Model_2nd_Equi", "Model_2nd_SDP", "Model_2nd_aSDP")
for (i in 1 : p) {
  corxxk[i, 1] <- sum(X[, i] * Xk_f_e[, i]) / sqrt(sum(X[, i]^2) * sum(Xk_f_e[, i]^2))
  corxxk[i, 2] <- sum(X[, i] * Xk_f_s[, i]) / sqrt(sum(X[, i]^2) * sum(Xk_f_s[, i]^2))
  corxxk[i, 3] <- cor(X[, i], Xk_m_g_e[, i])
  corxxk[i, 4] <- cor(X[, i], Xk_m_g_s[, i])
  corxxk[i, 5] <- cor(X[, i], Xk_m_g_a[, i])
  corxxk[i, 6] <- cor(X[, i], Xk_m_2_e[, i])
  corxxk[i, 7] <- cor(X[, i], Xk_m_2_s[, i])
  corxxk[i, 8] <- cor(X[, i], Xk_m_2_a[, i])
}
```

```{r, echo = FALSE}
hist(Cor.X[lower.tri(Cor.X)], main = "Histogram of population pairwise correlation of columns in X", xlab = expression(paste("Population ", cor(X[i], X[j]))))
hist(R.X[lower.tri(R.X)], main = "Histogram of sample normalized pairwise inner product of columns in X", xlab = expression(paste("Normalized ", X[i]^T~X[j])))
hist(Rho.X[lower.tri(Rho.X)], main = "Histogram of sample pairwise correlation of columns in X", xlab = expression(paste("Sample ", cor(X[i], X[j]))))
hist(Cor.betahat[lower.tri(Cor.betahat)], main = expression(paste("Histogram of population pairwise correlation of ", hat(beta))), xlab = expression(paste("Population ", cor(hat(beta)[i], hat(beta)[j]))))
par(mfrow = c(1, 1))
par(mar = c(9, 3.5, 2.5, 1.5))
boxplot(corxxk, las = 2, main = "Similarity between originals and their knockoffs")
```

### Fixed Design

```{r factor-betahat fixed, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
A <- 10
beta <- rep(0, p)
nonzero <- sample(p, k)
beta[nonzero] <- A

W <- result <- list()
for (i in 1 : m) {
  y <- X %*% beta + rnorm(n)

  ## Least squares
  lm.fit <- lm(y ~ X - 1)
  pvalue <- summary(lm.fit)$coefficients[, 4]

  ## BH
  BH.fit <- p.adjust(pvalue, method = "BH")
  BH.selected <- (1 : p)[BH.fit <= q]

  orig <- 1 : p
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::lasso_max_lambda(cbind(X, Xk_f_e)[, random.order.variable], y, method = "glmnet", family = "gaussian")
  Z <- Z[order(random.order.variable)]
  W_f_e_max <- pmax(Z[orig], Z[orig + p]) * sign(Z[orig] - Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::lasso_max_lambda(cbind(X, Xk_f_s)[, random.order.variable], y, method = "glmnet", family = "gaussian")
  Z <- Z[order(random.order.variable)]
  W_f_s_max <- pmax(Z[orig], Z[orig + p]) * sign(Z[orig] - Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_f_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  Xk_f_e_diff <- abs(Z[orig]) - abs(Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_f_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  Xk_f_s_diff <- abs(Z[orig]) - abs(Z[orig + p])

  ## Knockoff
  W[[i]] <- cbind(
    equi_max <- knockoff::stat.glmnet_lambdasmax(X, Xk_f_e, y),
    equi_max_random <- W_f_e_max,
    sdp_max <- knockoff::stat.glmnet_lambdasmax(X, Xk_f_s, y),
    sdp_max_random <- W_f_s_max,
    equi_diff <- knockoff::stat.glmnet_coefdiff(X, Xk_f_e, y, cores = ncores),
    equi_diff_random <- Xk_f_e_diff,
    sdp_diff <- knockoff::stat.glmnet_coefdiff(X, Xk_f_s, y, cores = ncores),
    sdp_diff_random <- Xk_f_s_diff
  )

  Knockoff.threshold <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 0)
  Knockoff.threshold.plus <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 1)

  fdp.Knockoff <- fdp.Knockoff.plus <- power.Knockoff <- power.Knockoff.plus <- c()
  for (j in 1 : ncol(W[[i]])) {
    fdp.Knockoff[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold[j]))
    fdp.Knockoff.plus[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold.plus[j]))
    power.Knockoff[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold[j])] != 0) / max(k, 1)
    power.Knockoff.plus[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold.plus[j])] != 0) / max(k, 1)
  }

  result[[i]] <- c(
    fdp(BH.selected), fdp.Knockoff, fdp.Knockoff.plus,
    power(BH.selected, k), power.Knockoff, power.Knockoff.plus
  )
}
```

```{r, echo = FALSE, message = FALSE}
par(mar = c(9, 4.5, 0.5, 0.5))
result.matrix <- matrix(unlist(result), m, byrow = TRUE)
boxplot(result.matrix[, 1 : 17], ylab = "FDP", las = 2, names = c(
  "BH",
  "KO.Equi.lambdasmax",
  "KO.Equi.lambdasmax.Rand",
  "KO.SDP.lambdasmax",
  "KO.SDP.lambdasmax.Rand",
  "KO.Equi.coefdiff",
  "KO.Equi.coefdiff.Rand",
  "KO.SDP.coefdiff",
  "KO.SDP.coefdiff.Rand",
  "KO+.Equi.lambdasmax",
  "KO+.Equi.lambdasmax.Rand",
  "KO+.SDP.lambdasmax",
  "KO+.SDP.lambdasmax.Rand",
  "KO+.Equi.coefdiff",
  "KO+.Equi.coefdiff.Rand",
  "KO+.SDP.coefdiff",
  "KO+.SDP.coefdiff.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 1 : 17]), col = "blue", pch = 3)
abline(h = q, lty = 2, col = "red")
abline(v = c(1.5, 9.5), col = "maroon")

boxplot(result.matrix[, 18 : 34], ylab = "TDP", las = 2, names = c(
  "BH",
  "KO.Equi.lambdasmax",
  "KO.Equi.lambdasmax.Rand",
  "KO.SDP.lambdasmax",
  "KO.SDP.lambdasmax.Rand",
  "KO.Equi.coefdiff",
  "KO.Equi.coefdiff.Rand",
  "KO.SDP.coefdiff",
  "KO.SDP.coefdiff.Rand",
  "KO+.Equi.lambdasmax",
  "KO+.Equi.lambdasmax.Rand",
  "KO+.SDP.lambdasmax",
  "KO+.SDP.lambdasmax.Rand",
  "KO+.Equi.coefdiff",
  "KO+.Equi.coefdiff.Rand",
  "KO+.SDP.coefdiff",
  "KO+.SDP.coefdiff.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 18 : 34]), col = "blue", pch = 3)
abline(v = c(1.5, 9.5), col = "maroon")

null <- setdiff(seq(p), nonzero)
W.sign <- lapply(W, apply, 2, function(x)(sum(x[null] > 0) / sum(x[null] != 0)))
W.sign <- matrix(unlist(W.sign), m, byrow = TRUE)
colnames(W.sign) <- c(
  "Equi + lambdasmax",
  "Equi + lambdasmax + Random",
  "SDP + lambdasmax",
  "SDP + lambdasmax + Random",
  "Equi + coefdiff",
  "Equi + coefdiff + Random",
  "SDP + coefdiff",
  "SDP + coefdiff + Random"
)

ggplot2::ggplot(data = reshape2::melt(as.data.frame(W.sign)), mapping = aes(x = value)) +
  geom_histogram(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~ variable, ncol = 2) +
  labs(x = "Proportion of Null Test Statistics Being Positive") +
  geom_vline(xintercept = 0.5, col = "red", linetype = "dashed")
```

### Model-$X$ Design

```{r factor-betahat model, echo = FALSE, cache = TRUE, message = FALSE, warning = FALSE}
A <- 10

nonzero.list <- W.sign <- W <- result <- list()

for (i in 1 : m) {
  X <- matrix(rnorm(n * p, 0, sqrt(1 / n)), n) %*% chol(Cor.X)

  Xk_m_g_e <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "equi")
  Xk_m_g_s <- knockoff::create.gaussian(X, mu = rep(0, p), Sigma = Cov.X, method = "sdp")
  Xk_m_2_e <- knockoff::create.second_order(X, method = "equi")
  Xk_m_2_s <- knockoff::create.second_order(X, method = "sdp")
  
  beta <- rep(0, p)
  nonzero <- sample(p, k)
  nonzero.list[[i]] <- nonzero
  null <- setdiff(seq(p), nonzero)
  beta[nonzero] <- A
  
  y <- X %*% beta + rnorm(n)
  
  ## Least squares
  lm.fit <- lm(y ~ X - 1)
  pvalue <- summary(lm.fit)$coefficients[, 4]

  ## BH
  BH.fit <- p.adjust(pvalue, method = "BH")
  BH.selected <- (1 : p)[BH.fit <= q]

  orig <- 1 : p
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_g_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_g_e <- abs(Z[orig]) - abs(Z[orig + p])

  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_g_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_g_s <- abs(Z[orig]) - abs(Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_2_e)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_2_e <- abs(Z[orig]) - abs(Z[orig + p])
  
  random.order.variable <- sample(2 * p)
  Z <- knockoff:::cv_coeffs_glmnet(cbind(X, Xk_m_2_s)[, random.order.variable], y, family = "gaussian", parallel = TRUE)
  Z <- Z[order(random.order.variable)]
  W_m_2_s <- abs(Z[orig]) - abs(Z[orig + p])

  ## Knockoff
  W[[i]] <- cbind(
    gauss_equi <- knockoff::stat.glmnet_coefdiff(X, Xk_m_g_e, y, cores = ncores),
    gauss_equi_random <- W_m_g_e,
    gauss_sdp <- knockoff::stat.glmnet_coefdiff(X, Xk_m_g_s, y, cores = ncores),
    gauss_sdp_random <- W_m_g_s,
    est_equi <- knockoff::stat.glmnet_coefdiff(X, Xk_m_2_e, y, cores = ncores),
    est_equi_random <- W_m_2_e,
    est_sdp <- knockoff::stat.glmnet_coefdiff(X, Xk_m_2_s, y, cores = ncores),
    est_sdp_random <- W_m_2_s
  )
  
  W.sign[[i]] <- apply(W[[i]], 2, function (x) {sum(x[null] > 0) / sum(x[null] != 0)})

  Knockoff.threshold <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 0)
  Knockoff.threshold.plus <- apply(W[[i]], 2, knockoff.threshold, fdr = q, offset = 1)

  fdp.Knockoff <- fdp.Knockoff.plus <- power.Knockoff <- power.Knockoff.plus <- c()
  for (j in 1 : ncol(W[[i]])) {
    fdp.Knockoff[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold[j]))
    fdp.Knockoff.plus[j] <- fdp(which(W[[i]][, j] >= Knockoff.threshold.plus[j]))
    power.Knockoff[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold[j])] != 0) / max(k, 1)
    power.Knockoff.plus[j] <- sum(beta[which(W[[i]][, j] >= Knockoff.threshold.plus[j])] != 0) / max(k, 1)
  }

  result[[i]] <- c(
    fdp(BH.selected), fdp.Knockoff, fdp.Knockoff.plus,
    power(BH.selected, k), power.Knockoff, power.Knockoff.plus
  )
}
```

```{r, echo = FALSE, message = FALSE}
par(mar = c(9, 4.5, 0.5, 0.5))
result.matrix <- matrix(unlist(result), m, byrow = TRUE)
boxplot(result.matrix[, 1 : 17], ylab = "FDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 1 : 17]), col = "blue", pch = 3)
abline(h = q, lty = 2, col = "red")
abline(v = c(1.5, 9.5), col = "maroon")

boxplot(result.matrix[, 18 : 34], ylab = "TDP", las = 2, names = c(
  "BH",
  "KO.Gauss.Equi",
  "KO.Gauss.Equi.Rand",
  "KO.Gauss.SDP",
  "KO.Gauss.SDP.Rand",
  "KO.2nd.Equi",
  "KO.2nd.Equi.Rand",
  "KO.2nd.SDP",
  "KO.2nd.SDP.Rand",
  "KO+.Gauss.Equi",
  "KO+.Gauss.Equi.Rand",
  "KO+.Gauss.SDP",
  "KO+.Gauss.SDP.Rand",
  "KO+.2nd.Equi",
  "KO+.2nd.Equi.Rand",
  "KO+.2nd.SDP",
  "KO+.2nd.SDP.Rand"
), cex.axis = 0.75, border = c("green", rep(c("black", "red"), 8))
)
points(colMeans(result.matrix[, 18 : 34]), col = "blue", pch = 3)
abline(v = c(1.5, 9.5), col = "maroon")

W.sign.matrix <- matrix(unlist(W.sign), m, byrow = TRUE)
colnames(W.sign.matrix) <- c(
  "Gauss + Equi",
  "Gauss + Equi + Random",
  "Gauss + SDP",
  "Gauss + SDP + Random",
  "2nd + Equi",
  "2nd + Equi + Random",
  "2nd + SDP",
  "2nd + SDP + Random"
)

ggplot2::ggplot(data = reshape2::melt(as.data.frame(W.sign.matrix)), mapping = aes(x = value)) +
  geom_histogram(breaks = seq(0, 1, by = 0.05)) +
  facet_wrap(~ variable, ncol = 2) +
  labs(x = "Proportion of Null Test Statistics Being Positive") +
  geom_vline(xintercept = 0.5, col = "red", linetype = "dashed")
```

## Observation

Model-$X$ knockoff indeed increases power substantially.

- Reason 1: it builds better knockoffs as they are less similar to originals, since Model-$X$ is about population correlation not sample correlation.

- Reason 2: Model-$X$ unleashes a large swarm of complicated test statistics which are not applicable for Fixed-$X$.

However, for that particular case when we have $$\Sigma_\hat\beta$$ as a factor model, Model-$X$ knockoffs are still not good.


